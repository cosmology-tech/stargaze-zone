"use strict";
/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuctionEnglishClient = exports.AuctionEnglishQueryClient = void 0;
class AuctionEnglishQueryClient {
    client;
    contractAddress;
    constructor(client, contractAddress) {
        this.client = client;
        this.contractAddress = contractAddress;
        this.config = this.config.bind(this);
        this.auction = this.auction.bind(this);
        this.auctionsByStartTime = this.auctionsByStartTime.bind(this);
        this.auctionsByEndTime = this.auctionsByEndTime.bind(this);
        this.auctionsByHighestBidPrice = this.auctionsByHighestBidPrice.bind(this);
        this.auctionsBySellerEndTime = this.auctionsBySellerEndTime.bind(this);
        this.auctionsByBidderEndTime = this.auctionsByBidderEndTime.bind(this);
    }
    config = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            config: {}
        });
    };
    auction = async ({ tokenId }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            auction: {
                token_id: tokenId
            }
        });
    };
    auctionsByStartTime = async ({ queryOptions }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            auctions_by_start_time: {
                query_options: queryOptions
            }
        });
    };
    auctionsByEndTime = async ({ queryOptions }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            auctions_by_end_time: {
                query_options: queryOptions
            }
        });
    };
    auctionsByHighestBidPrice = async ({ queryOptions }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            auctions_by_highest_bid_price: {
                query_options: queryOptions
            }
        });
    };
    auctionsBySellerEndTime = async ({ queryOptions, seller }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            auctions_by_seller_end_time: {
                query_options: queryOptions,
                seller
            }
        });
    };
    auctionsByBidderEndTime = async ({ bidder, queryOptions }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            auctions_by_bidder_end_time: {
                bidder,
                query_options: queryOptions
            }
        });
    };
}
exports.AuctionEnglishQueryClient = AuctionEnglishQueryClient;
class AuctionEnglishClient extends AuctionEnglishQueryClient {
    client;
    sender;
    contractAddress;
    constructor(client, sender, contractAddress) {
        super(client, contractAddress);
        this.client = client;
        this.sender = sender;
        this.contractAddress = contractAddress;
        this.updateConfig = this.updateConfig.bind(this);
        this.setAuction = this.setAuction.bind(this);
        this.setAuctionBid = this.setAuctionBid.bind(this);
        this.closeAuction = this.closeAuction.bind(this);
        this.finalizeAuction = this.finalizeAuction.bind(this);
        this.voidAuction = this.voidAuction.bind(this);
    }
    updateConfig = async ({ bufferDuration, closedDuration, collectorAddress, maxDuration, minBidIncrement, minDuration, minPrice, operators, tradingFeeBps }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            update_config: {
                buffer_duration: bufferDuration,
                closed_duration: closedDuration,
                collector_address: collectorAddress,
                max_duration: maxDuration,
                min_bid_increment: minBidIncrement,
                min_duration: minDuration,
                min_price: minPrice,
                operators,
                trading_fee_bps: tradingFeeBps
            }
        }, fee, memo, _funds);
    };
    setAuction = async ({ endTime, fundsRecipient, reservePrice, startTime, startingPrice, tokenId }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            set_auction: {
                end_time: endTime,
                funds_recipient: fundsRecipient,
                reserve_price: reservePrice,
                start_time: startTime,
                starting_price: startingPrice,
                token_id: tokenId
            }
        }, fee, memo, _funds);
    };
    setAuctionBid = async ({ price, tokenId }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            set_auction_bid: {
                price,
                token_id: tokenId
            }
        }, fee, memo, _funds);
    };
    closeAuction = async ({ acceptHighestBid, tokenId }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            close_auction: {
                accept_highest_bid: acceptHighestBid,
                token_id: tokenId
            }
        }, fee, memo, _funds);
    };
    finalizeAuction = async ({ tokenId }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            finalize_auction: {
                token_id: tokenId
            }
        }, fee, memo, _funds);
    };
    voidAuction = async ({ tokenId }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            void_auction: {
                token_id: tokenId
            }
        }, fee, memo, _funds);
    };
}
exports.AuctionEnglishClient = AuctionEnglishClient;
//# sourceMappingURL=AuctionEnglish.client.js.map