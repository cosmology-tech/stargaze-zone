"use strict";
/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pg721Client = exports.Pg721QueryClient = void 0;
class Pg721QueryClient {
    client;
    contractAddress;
    constructor(client, contractAddress) {
        this.client = client;
        this.contractAddress = contractAddress;
        this.ownerOf = this.ownerOf.bind(this);
        this.approval = this.approval.bind(this);
        this.approvals = this.approvals.bind(this);
        this.allOperators = this.allOperators.bind(this);
        this.numTokens = this.numTokens.bind(this);
        this.contractInfo = this.contractInfo.bind(this);
        this.nftInfo = this.nftInfo.bind(this);
        this.allNftInfo = this.allNftInfo.bind(this);
        this.tokens = this.tokens.bind(this);
        this.allTokens = this.allTokens.bind(this);
        this.minter = this.minter.bind(this);
        this.collectionInfo = this.collectionInfo.bind(this);
    }
    ownerOf = async ({ includeExpired, tokenId }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            owner_of: {
                include_expired: includeExpired,
                token_id: tokenId
            }
        });
    };
    approval = async ({ includeExpired, spender, tokenId }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            approval: {
                include_expired: includeExpired,
                spender,
                token_id: tokenId
            }
        });
    };
    approvals = async ({ includeExpired, tokenId }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            approvals: {
                include_expired: includeExpired,
                token_id: tokenId
            }
        });
    };
    allOperators = async ({ includeExpired, limit, owner, startAfter }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            all_operators: {
                include_expired: includeExpired,
                limit,
                owner,
                start_after: startAfter
            }
        });
    };
    numTokens = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            num_tokens: {}
        });
    };
    contractInfo = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            contract_info: {}
        });
    };
    nftInfo = async ({ tokenId }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            nft_info: {
                token_id: tokenId
            }
        });
    };
    allNftInfo = async ({ includeExpired, tokenId }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            all_nft_info: {
                include_expired: includeExpired,
                token_id: tokenId
            }
        });
    };
    tokens = async ({ limit, owner, startAfter }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            tokens: {
                limit,
                owner,
                start_after: startAfter
            }
        });
    };
    allTokens = async ({ limit, startAfter }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            all_tokens: {
                limit,
                start_after: startAfter
            }
        });
    };
    minter = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            minter: {}
        });
    };
    collectionInfo = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            collection_info: {}
        });
    };
}
exports.Pg721QueryClient = Pg721QueryClient;
class Pg721Client extends Pg721QueryClient {
    client;
    sender;
    contractAddress;
    constructor(client, sender, contractAddress) {
        super(client, contractAddress);
        this.client = client;
        this.sender = sender;
        this.contractAddress = contractAddress;
        this.transferNft = this.transferNft.bind(this);
        this.sendNft = this.sendNft.bind(this);
        this.approve = this.approve.bind(this);
        this.revoke = this.revoke.bind(this);
        this.approveAll = this.approveAll.bind(this);
        this.revokeAll = this.revokeAll.bind(this);
        this.mint = this.mint.bind(this);
        this.burn = this.burn.bind(this);
    }
    transferNft = async ({ recipient, tokenId }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            transfer_nft: {
                recipient,
                token_id: tokenId
            }
        }, fee, memo, _funds);
    };
    sendNft = async ({ contract, msg, tokenId }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            send_nft: {
                contract,
                msg,
                token_id: tokenId
            }
        }, fee, memo, _funds);
    };
    approve = async ({ expires, spender, tokenId }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            approve: {
                expires,
                spender,
                token_id: tokenId
            }
        }, fee, memo, _funds);
    };
    revoke = async ({ spender, tokenId }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            revoke: {
                spender,
                token_id: tokenId
            }
        }, fee, memo, _funds);
    };
    approveAll = async ({ expires, operator }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            approve_all: {
                expires,
                operator
            }
        }, fee, memo, _funds);
    };
    revokeAll = async ({ operator }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            revoke_all: {
                operator
            }
        }, fee, memo, _funds);
    };
    mint = async ({ extension, owner, tokenId, tokenUri }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            mint: {
                extension,
                owner,
                token_id: tokenId,
                token_uri: tokenUri
            }
        }, fee, memo, _funds);
    };
    burn = async ({ tokenId }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            burn: {
                token_id: tokenId
            }
        }, fee, memo, _funds);
    };
}
exports.Pg721Client = Pg721Client;
//# sourceMappingURL=Pg721.client.js.map