"use strict";
/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.MinterMetadaOnChainClient = exports.MinterMetadaOnChainQueryClient = void 0;
class MinterMetadaOnChainQueryClient {
    client;
    contractAddress;
    constructor(client, contractAddress) {
        this.client = client;
        this.contractAddress = contractAddress;
        this.config = this.config.bind(this);
        this.numMinted = this.numMinted.bind(this);
        this.numRemaining = this.numRemaining.bind(this);
        this.startTime = this.startTime.bind(this);
        this.mintPrice = this.mintPrice.bind(this);
        this.mintCount = this.mintCount.bind(this);
        this.tokenMint = this.tokenMint.bind(this);
        this.tokenMints = this.tokenMints.bind(this);
    }
    config = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            config: {}
        });
    };
    numMinted = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            num_minted: {}
        });
    };
    numRemaining = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            num_remaining: {}
        });
    };
    startTime = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            start_time: {}
        });
    };
    mintPrice = async () => {
        return this.client.queryContractSmart(this.contractAddress, {
            mint_price: {}
        });
    };
    mintCount = async ({ address }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            mint_count: {
                address
            }
        });
    };
    tokenMint = async ({ tokenId }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            token_mint: {
                token_id: tokenId
            }
        });
    };
    tokenMints = async ({ descending, filterMinted, limit, startAfter }) => {
        return this.client.queryContractSmart(this.contractAddress, {
            token_mints: {
                descending,
                filter_minted: filterMinted,
                limit,
                start_after: startAfter
            }
        });
    };
}
exports.MinterMetadaOnChainQueryClient = MinterMetadaOnChainQueryClient;
class MinterMetadaOnChainClient extends MinterMetadaOnChainQueryClient {
    client;
    sender;
    contractAddress;
    constructor(client, sender, contractAddress) {
        super(client, contractAddress);
        this.client = client;
        this.sender = sender;
        this.contractAddress = contractAddress;
        this.upsertTokenMetadatas = this.upsertTokenMetadatas.bind(this);
        this.mint = this.mint.bind(this);
        this.setAdmin = this.setAdmin.bind(this);
        this.setWhitelist = this.setWhitelist.bind(this);
        this.updateStartTime = this.updateStartTime.bind(this);
        this.updatePerAddressLimit = this.updatePerAddressLimit.bind(this);
        this.updateUnitPrice = this.updateUnitPrice.bind(this);
        this.mintTo = this.mintTo.bind(this);
        this.mintFor = this.mintFor.bind(this);
        this.withdraw = this.withdraw.bind(this);
    }
    upsertTokenMetadatas = async ({ tokenMetadatas }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            upsert_token_metadatas: {
                token_metadatas: tokenMetadatas
            }
        }, fee, memo, _funds);
    };
    mint = async (fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            mint: {}
        }, fee, memo, _funds);
    };
    setAdmin = async ({ admin }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            set_admin: {
                admin
            }
        }, fee, memo, _funds);
    };
    setWhitelist = async ({ whitelist }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            set_whitelist: {
                whitelist
            }
        }, fee, memo, _funds);
    };
    updateStartTime = async (fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            update_start_time: {}
        }, fee, memo, _funds);
    };
    updatePerAddressLimit = async ({ perAddressLimit }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            update_per_address_limit: {
                per_address_limit: perAddressLimit
            }
        }, fee, memo, _funds);
    };
    updateUnitPrice = async ({ unitPrice }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            update_unit_price: {
                unit_price: unitPrice
            }
        }, fee, memo, _funds);
    };
    mintTo = async ({ recipient }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            mint_to: {
                recipient
            }
        }, fee, memo, _funds);
    };
    mintFor = async ({ recipient, tokenId }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            mint_for: {
                recipient,
                token_id: tokenId
            }
        }, fee, memo, _funds);
    };
    withdraw = async ({ recipient }, fee = "auto", memo, _funds) => {
        return await this.client.execute(this.sender, this.contractAddress, {
            withdraw: {
                recipient
            }
        }, fee, memo, _funds);
    };
}
exports.MinterMetadaOnChainClient = MinterMetadaOnChainClient;
//# sourceMappingURL=MinterMetadaOnChain.client.js.map